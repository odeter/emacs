from faker import Faker
import numpy as np
import pandas as pd
import secrets
from geopy.geocoders import Nominatim
from geopy.exc import GeocoderTimedOut, GeocoderUnavailable
import random
from sqlalchemy import text
from tqdm import tqdm

def chunker(seq, size):
    # from http://stackoverflow.com/a/434328
    return (seq[pos:pos + size] for pos in range(0, len(seq), size))

def insert_with_progress(data, cursor, table_name, sensor_id):
    #con = sqlite3.connect(dbfile)
    chunksize = int(len(data) / 10) # 10%
    with tqdm(total=len(df)) as pbar:
        ch = 0
        for i, cdf in enumerate(chunker(data, chunksize)):
            ch += chunksize
            replace = "replace" if i == 0 else "append"
            cdf.to_sql(table_name, con=cursor, if_exists=replace, index=False)
            pbar.update(chunksize)


def gen_conn_list(app, fake, count, size):
    c_list = []
    chunksize = int(count / 10)
    with tqdm(total=len(df)) as pbar:
        for i in range(count):
            insert_time = fake.date_between(start_date='-1w', end_date='today')
            time = fake.date_between(start_date='-1y', end_date='today')
            number = fake.random_number(size)
            temp = [[insert_time, time, fake.ipv4(), fake.port_number(), fake.ipv4(), fake.port_number()]] * number
            c_list = c_list + temp
            pbar.update(chunksize)

    return c_list


def create_test_logs(sensor_id, cursor, fake, log_type, count, size):

    columns = "(id SERIAL PRIMARY KEY, sensor_id INTEGER REFERENCES sensor(sensor_id),"+\
        " insert_ts TIMESTAMP, ts TIMESTAMP, id_orig_h TEXT, id_orig_p INTEGER, id_resp_h TEXT, id_resp_p INTEGER)"
    col_order = "ts,id_orig_h,id_orig_p,id_resp_h,id_resp_p"
    field_types = "text,int,text,int,timestamp"
    column_names = "id_orig_h,id_orig_p,id_resp_h,id_resp_p,ts"

    nt_name = log_type+'_test'

    print("making stuff for the "+log_type)

    getDT = "SELECT table_name, id FROM dto WHERE table_name=%s"
    result = cursor.execute(getDT, (nt_name))
    row = result.first()
    if row:
        commit_table = row[0]
        table_id = row[1]
        getDT = "SELECT * FROM dthelper WHERE dt_id=%s AND sensor_id=%s"
        result = cursor.execute(getDT, (table_id, sensor_id))
        dt_help = result.first()
        if not dt_help:
                cursor.execute("INSERT INTO dthelper (sensor_id, dt_id) VALUES (%s, %s)", (sensor_id, table_id))
    else:
        conn_query = "CREATE TABLE  %s %s" % (nt_name, columns)
        create_index_insert_ts = "CREATE INDEX %s_insertts_index ON %s (insert_ts);" % (nt_name, nt_name)
        create_index_ts = "CREATE INDEX %s_ts_index ON %s (ts);" % (nt_name, nt_name)
        create_index_sensor = "CREATE INDEX %s_sensor_index ON %s (sensor_id);" % (nt_name, nt_name)
        dto_up = "INSERT INTO dto (table_name, cols_number, field_types, column_order, column_names, log_type, toc) VALUES(%s, %s, %s, %s, %s, %s, %s)"
        try:
            dt = datetime.now()
            cursor.execute(text(conn_query))
            cursor.execute(text(create_index_ts))
            cursor.execute(text(create_index_insert_ts))
            cursor.execute(text(create_index_sensor))
            cursor.execute(dto_up, (nt_name, 5, field_types, col_order, column_names, log_type, dt))
        except SQLAlchemyError as e:
            error = str(e.__dict__['orig']).replace('\n', ' ')
            exit(error)
        except Exception as err:
            cursor.close()
            exit(err)

    #dt_frame = pd.DataFrame(gen_conn_list(fake, count, size), columns=['insert_ts', "ts", "id_orig_h", "id_orig_p", "id_resp_h", "id_resp_p"])
    #dt_frame.to_sql(nt_name, con=db.engine, if_exists='append', index=False)

    print(nt_name+": Generate data list")
    gen_data = gen_conn_list(fake, count, size)
    print(nt_name+": Generate data list")
    insert_with_progress(gen_data, cursor, nt_name, sensor_id)

    # for i in users:
    #     #print(i['email'])
    #     test_user = models.UserModel.find_by_username(i['email'])

    #     firm = test_user.firm
    #     sensor = firm.sensors.first()

    #     #print("generating rows")

    #     dt_frame = pd.DataFrame(gen_conn_list(app, fake, app.config['GEN_LOOP']), columns=['insert_ts', "ts", "id_orig_h", "id_orig_p", "id_resp_h", "id_resp_p"])

    #     #print("done generating")

    #     dto.add_sensor(sensor)
    #     dto.save_to_db()

    #     dt_frame['sensor_id'] = sensor.sensor_id
    #     #insert_with_progress(dt_frame, db, dto.table_name, i['email'])
    #     dt_frame.to_sql(dto.table_name, con=db.engine, if_exists='append', index=False)
    # print("done inserting")
    return nt_name

def create_test_alarms(db, test_users, fake, tname):

    ## need to create relation between alarm and conn table, e.g insert with data ts and data uid
    dto = models.DynamicOverview.find_by_name(tname)

    alarms = [['malware', 100], ['TCP SYN flood attack', 100],
              ['Teardrop attack', 100], ['Smurf attack', 100],
              ['Ping of death attack', 100], ['Missing SSL Cert', 100],
              ['Banking Phish', 100]]

    alarm_types = {'malware': 'riskUrgent',
                   'TCP SYN flood attack': 'riskPotential',
                   'Teardrop attack' : 'riskUrgent',
                   'Smurf attack' : 'riskUrgent',
                   'Ping of death attack' : 'riskUrgent',
                   'Missing SSL Cert': 'riskPotential',
                   'Banking Phish' : 'riskCritical'}

    for i in test_users:
        test_user = models.UserModel.find_by_username(i['email'])

        firm = test_user.firm
        sensor = firm.sensors.first()
        dataTable = dto
        for j in alarms:
            alarm_count = random.randint(1, 10)
            for i in range(alarm_count):
                time = fake.date_between(start_date='-1y', end_date='today')#random_date("1/1/2020 1:30", "9/29/2020 22:50", random.random())
                a_level = models.AlarmLevelModel.find_by_name(alarm_types[j[0]])
                gen_status = int(np.random.choice([0,1,2], p=[0.1, 0.2, 0.7]))
                new_alarm = models.AlarmModel(alarm_name='test_alarm', description='test_alarm',
                                              alarm_type=j[0], status=gen_status, toc=time)
                sensor.add_alarm(new_alarm)
                a_level.add_alarm(new_alarm)
                dataTable.add_alarm(new_alarm)
                test_user.add_alarm(new_alarm)
                new_alarm.save_to_db()

def generate_test_data(sensor_id, cursor):
    fake = Faker('dk_DK')

    create_test_logs(cursor, fake, sensor_id, 'http')

if __name__== "__main__":
    db_url = os.environ['DATABASE_URL']
    engine = create_engine(db_url)
    cursor = engine.connect()
    args = sys.argv
    sensor_id = None
    if len(args) == 2 and args[1]:
        sensor_id = int(args[1])
    else:
        exit('Sensor id is required')
    generate_test_data(sensor_id, cursor)

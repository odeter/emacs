from flask_restful import Resource, reqparse
from angle.models import UserModel, RevokedTokenModel, SensorModel, DynamicOverview, RoleModel, AlarmNotifyModel, AlarmModel, AlarmLevelModel, GroupModel, RegkeysModel
from flask_jwt_extended import (create_access_token, create_refresh_token, jwt_required, jwt_refresh_token_required, get_jwt_identity, get_raw_jwt, get_jwt_claims)
from flask import request, jsonify, make_response
import json
import requests
import validators
import werkzeug
import uuid
import os, stat, sys
import re
import time
from datetime import datetime as dt
from datetime import timedelta
import csv
import numpy as np
from angle.libpnffilter import Pnffilter
from angle import app, db, role_required
import shutil
import secrets
from collections import OrderedDict
from functools import wraps
import sqlalchemy
import time

storage = app.config['UPLOAD_FOLDER']
data_folder = app.config['UPLOAD_FOLDER'] + "/" + app.config['STREAM_FOLDER']
csv_folder = app.config['CSV_FOLDER']

def check_email(email):
    regex = '^[a-øA-Ø0-9]+([\.-]?\w+)*@[a-øA-Ø0-9]+([\.-]?\w+)*(\.\w{2,3})+$'
    return re.search(regex, email)

## for loading helper page information
def get_tips(fileName):
    res = []
    with open(fileName, 'r') as csv_file:
        csv_reader = csv.reader(csv_file, delimiter='|')
        count = 0
        for row in csv_reader:
            res.append(row)
        csv_file.close()
    return res

def getMaxL(objs):
    vl = [len(v["header"]) for v in objs.values()]
    return max(vl)


def search(logList, startP, search_val):
    search_area = logList[startP:]
    x = None
    y = None
    is_int = search_val.isdecimal()
    for i in range(0, len(search_area)):
        row = search_area[i]
        for j in range(0, len(row)):
            element = row[j]
            el_int =(isinstance(element, int) or isinstance(element, dt))
            print(element)
            print
            if (is_int and search_val == element) or (not is_int and not el_int and (search_val in element)):
                x = (startP + i)
                y = j
                break
    return x, y

def cut(logList, startP, sizeM):
    return logList[startP:(sizeM + startP)]

def formatLogData(objs, maxHL, single=True):
    logList = []
    logHeaders = []
    filesIDList = {}

    if single:
        it = list(objs['files'].items())[0]
        key = it[0]
        val = it[1]
        hds = val['header']
        logList = val['rows'] #[[key] + x for x in val['rows']]
        filesIDList[key] = 0
        logHeaders.append(hds) #append([key] + hds)
        print("single chosen")
        return logList, logHeaders, filesIDList
    else:
        connrows = objs['files']['conn']['rows']
        uidpos = 0
        while uidpos < len(objs['files']['conn']['header']):
            if objs['files']['conn']['header'][uidpos] == 'uid':
                break
            uidpos = uidpos + 1
        connlen = len(connrows)

        connuids = {}
        orphanlist = {}
        for i in range(0, connlen):
            connuids[connrows[i][1]] = ''

        fid = 0
        for key, val in objs['files'].items():
            hds = val['header']
            new_h = hds if maxHL == len(hds) else hds + (['-'] * (maxHL - len(hds)))
            logHeaders.append(new_h)
            filesIDList[key] = fid
            fid += 1
            if (key == 'conn'):
                continue
            rows = val['rows']
            rowLen = len(rows)
            lastNonOrpId = ''
            for i in range(0, rowLen):
                if(len(rows[i]) > 1 and rows[i][1] in connuids):
                    lastNonOrpId = rows[i][1]
                elif(lastNonOrpId in orphanlist):
                    orphanlist[lastNonOrpId].append(rows[i])
                else:
                    orphanlist[lastNonOrpId] = [rows[i]]
        # orphans
        if ('' in orphanlist):
            for i in range(0,len(orphanlist[''])):
                orp = orphanlist[''][i] if isinstance(orphanlist[''][i], list) else [orphanlist[''][i]]
                orpMD = orp if len(orp) == (maxHL + 1) else orp + (['-'] * ((maxHL + 1) - len(orp)))
                logList.append(orpMD)

        subtablelookupdicts = {}
        for key, val in objs['files'].items():
            if(key == 'conn'):
                continue
            subrows = val['rows']
            sublen = len(subrows)
            subheader = val['header']
            subuidpos = 0
            while subuidpos < len(subheader):
                if subheader[subuidpos] == 'uid':
                    break
                subuidpos = subuidpos + 1

            subtablelookupdicts[key] = {}
            if 'uid' not in subheader:
                continue
            for j in range(0, sublen):
                subMD = subrows[j] if len(subrows) == maxHL + 1 \
                    else subrows[j] + (['-'] * (maxHL - len(subrows[j])))
                if subrows[j][subuidpos] not in subtablelookupdicts[key]:
                    subtablelookupdicts[key][subrows[j][subuidpos]] = [subMD]
                else:
                    subtablelookupdicts[key][subrows[j][subuidpos]].append(subMD)

        for i in range(0, connlen):
        #for i in range(0, 10):
            conMD = connrows[i] if len(connrows) == maxHL + 1 \
                else connrows[i] + (['-'] * (maxHL - len(connrows[i])))
            logList.append(['conn'] + conMD)
            connuid = connrows[i][uidpos]
            for key in objs['files']:
                if(key == 'conn'):
                    continue
                if key in subtablelookupdicts and connuid in subtablelookupdicts[key]:
                    for subMD in subtablelookupdicts[key][connuid]:
                        logList.append(subMD)
            if connuid in orphanlist:
                for orpIndex in range(0, len(orphanlist[connuid])):
                    logList.append(orphanlist[connuid][orpIndex])

        return logList, logHeaders, filesIDList

def formatdata(objs, maxHL):
    logList = []
    logHeaders = []
    filesIDList = {}


    connrows = objs['files']['conn.log']['rows']
    connlen = len(connrows)

    connuids = {}
    orphanlist = {}
    for i in range(0, connlen):
        connuids[connrows[i][1]] = ''

    fid = 0
    for key, val in objs['files'].items():
        hds = val['header']
        new_h = hds if maxHL == len(hds) else hds + (['-'] * (maxHL - len(hds)))
        logHeaders.append([key] + new_h)
        filesIDList[key] = fid
        fid += 1
        if (key == 'conn.log'):
            continue
        rows = val['rows']
        rowLen = len(rows)
        lastNonOrpId = ''
        for i in range(0, rowLen):
            if(len(rows[i]) > 1 and rows[i][1] in connuids):
                lastNonOrpId = rows[i][1]
            elif(lastNonOrpId in orphanlist):
                orphanlist[lastNonOrpId].append([key] + rows[i])
            else:
                orphanlist[lastNonOrpId] = [[key] + rows[i]]

    # orphans
    if ('' in orphanlist):
        for i in range(0,len(orphanlist[''])):
            orp = orphanlist[''][i] if isinstance(orphanlist[''][i], list) else [orphanlist[''][i]]
            orpMD = orp if len(orp) == (maxHL + 1) else orp + (['-'] * ((maxHL + 1) - len(orp)))
            logList.append(orpMD)

    for i in range(0, connlen):
        conMD = connrows[i] if len(connrows) == maxHL + 1 \
            else connrows[i] + (['-'] * (maxHL - len(connrows[i])))
        logList.append(['conn.log'] + conMD)
        connuid = connrows[i][1]

        for key, val in objs['files'].items():
            if(key == 'conn.log'):
                continue
            subrows = val['rows']
            sublen = len(subrows)

            for j in range(0, sublen):
                if len(subrows[j]) > 1 and subrows[j][1] == connuid:
                    subMD = subrows[j] if len(subrows) == maxHL + 1 \
                        else subrows[j] + (['-'] * (maxHL - len(subrows[j])))
                    logList.append([key] + subMD)

        if connuid in orphanlist:
            for orpIndex in range(0, len(orphanlist[connuid])):
                logList.append(orphanlist[connuid][orpIndex])

    return logList, logHeaders, filesIDList

# temp function, should run over sql call when filter is properly implemented
def hideCol(objs, hideC):
    cut_version = objs['files']
    #hdL = []
    for key, val in objs['files'].items():
        fc = []
        hds = val['header']
        if key in hideC :
            cut_h = val["header"].copy()
            #cut_t = val["types"].copy()
            cut_r = val["rows"].copy()
            for idx, item in enumerate(hds):
                #active_b = False
                if item in hideC[key]:
                    #active_b = True
                    i = cut_h.index(item)
                    cut_h.pop(i)
                    #cut_t.pop(i)
                    cut_r = (np.delete(cut_r, i ,1)).tolist()
                #fc.append({'file_h': key, 'head_n': item, 'index': idx,'is_set': active_b})
            #cut_version[key] = {'header': cut_h, "types": cut_t, "rows": cut_r}
            cut_version[key] = {'header': cut_h, "rows": cut_r}
        # else:
        #     for idx, item in enumerate(hds):
        #         active_b = False
        #         fc.append({'file_h': key, 'head_n': item, 'index': idx,'is_set': active_b})
        # hdL.extend(fc)
    objs['files'] = cut_version
    #print("this is the cut_verison:", cut_version)
    return objs
        #print("this is the value:", val)

parser = reqparse.RequestParser()
parser.add_argument('username', help = 'This field cannot be blank', required = True)
parser.add_argument('password', help = 'This field cannot be blank', required = True)

filterparser = reqparse.RequestParser()
filterparser.add_argument('filter', help = 'This field cannot be blank', required = True)

keyParser = reqparse.RequestParser()
keyParser.add_argument('username', help = 'This field cannot be blank', required = True)
keyParser.add_argument('apikey', help = 'This field cannot be blank', required = True)

setkeyParser = reqparse.RequestParser()
setkeyParser.add_argument('sensorName', help = 'This field cannot be blank', required = True)
setkeyParser.add_argument('sensorDesc')


class ReceiveData(Resource):
    def post(self):
        keyParser.add_argument('file', type=werkzeug.datastructures.FileStorage, location='files')
        data = keyParser.parse_args()
        pcapFile = data['file']
        fileuuid = uuid.uuid4()
        username = data['username']
        apikey = data['apikey']
        # TODO: Check current_user var for bad chars. Perhaps have a uuid per user instead.
        if pcapFile:
            if  UserModel.check_apikey(username, apikey):#checkapikey(username, data['apikey']):
                current_user = UserModel.find_by_username(username)
                userID = current_user.get_ID()
                sensorID = (current_user.find_sensor(apikey)).get_ID()
                if not os.path.isdir(data_folder+"incoming/" + userID + "/" + sensorID):
                    os.makedirs(data_folder+"incoming/" + userID + "/" + sensorID)
                fileName = str(fileuuid) + ".gz"
                pcapFile.save(data_folder+"incoming/" + userID + "/" + sensorID + "/" + fileName)
                if not os.path.isdir(data_folder+"done/" + userID + "/" + sensorID):
                    os.makedirs(data_folder+"done/" + userID + "/" + sensorID)
                    os.chmod(data_folder+"done/" + userID + "/" + sensorID, stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IXOTH)
                shutil.move(data_folder+"incoming/" + userID + "/" + sensorID + "/" + fileName,
                            data_folder+"done/" + userID + "/" + sensorID + "/" + fileName)
                return {'message': 'file received'}, 200
            else:
                return {'message': 'apikey not set or wrong api login credentials'}, 403
        else:
            return {'message': 'no file was sent'}, 500

# Create new api key for sensor
class CreateSensor(Resource):
    @role_required(["admin"])
    def post(self):
        data = setkeyParser.parse_args()
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)

        if current_user:
            sensor_name = data['sensorName']
            sensor_desc = data['sensorDesc'] if data['sensorDesc'] else None
            api_K = secrets.token_hex(15)
            print("api key generated:", api_K)
            sensor = SensorModel(api_key = api_K, name = sensor_name, description = sensor_desc)
            current_user.add_sensor(sensor)
            try:
                sensor.save_to_db()
                return {'message': 'Sensor Created'}, 200
            except:
                return {'message': 'Something went wrong'}, 500
        else:
            return {'message': 'User not set properly'}, 403

class CreateAlarm(Resource):
    @role_required(["admin", "op_man", "it_man", "it_sec"])
    def post(self):
        alarmParser = reqparse.RequestParser()
        alarmParser.add_argument('aName', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('aDesc', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('aType', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('aSensor', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('aTable', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('aDTS', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('aLevel', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('aNoti', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('aDataID', help = 'This field cannot be blank', required = True)
        data = alarmParser.parse_args()
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        if current_user:
            alarm_admin = current_user.find_prole("admin")
            if alarm_admin:
                alarm_name   = data['aName']
                alarm_desc   = data['aDesc']
                alarm_type   = data['aType']
                alarm_sensor = json.loads(data['aSensor'])
                alarm_logid  = json.loads(data['aTable'])
                alarm_dts    = json.loads(data['aDTS'])
                alarm_level  = json.loads(data['aLevel'])
                alarm_Notify = json.loads(data['aNoti'])
                alarm_dataid = json.loads(data['aDataID'])

                sensor = SensorModel.find_sensor(alarm_admin.id, alarm_sensor)
                dataTable = alarm_admin.get_logTable(alarm_sensor, alarm_logid)
                a_level = AlarmLevelModel.get_Level(alarm_level)
                if sensor and dataTable and a_level:
                    new_alarm = AlarmModel(alarm_name=alarm_name, description=alarm_desc, alarm_type=alarm_type, status=0, data_serial=alarm_dataid)
                    new_alarm.data_ts = alarm_dts
                    # Check to see if raw data can be found, e.g row in dto

                    sensor.add_alarm(new_alarm)
                    a_level.add_alarm(new_alarm)
                    dataTable.add_alarm(new_alarm)
                    print("bobily")
                    print(alarm_Notify)
                    if alarm_Notify >= 0:
                        notify = alarm_admin.get_notice(alarm_Notify)
                        notify.add_alarm(new_alarm)
                        if validators.url(notify.url):
                            headers = {'content-type': 'application/json'}
                            try:
                                r = requests.post(notify.url, headers=headers)
                                if r.status_code != 200:
                                    return {'message': 'Notify link was not accepted'}, 500
                            except requests.exceptions.RequestException as e:
                                return {'message': 'Notify link was not accepted'}, 500
                        else:
                            return {'message': 'Notify url was not valid'}, 500
                    current_user.add_alarm(new_alarm)
                    new_alarm.save_to_db()
                    return {'message': 'Alarm raised'}, 200
                else:
                    return {'message': 'Sensor and/or log table not found'}, 403
            else:
                return {'message': 'User is orphan'}, 403
        else:
            return {'message': 'User not set properly'}, 403



# Edit Alarm
class EditAlarm(Resource):
    @role_required(["admin", "op_man", "it_man", "it_sec"])
    def post(self):
        alarmParser = reqparse.RequestParser()
        alarmParser.add_argument('aID', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('aStatus', help = 'This field cannot be blank', required = True)
        data = alarmParser.parse_args()
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)

        if current_user:
            alarm_admin = current_user.find_prole("admin")
            if alarm_admin:
                alarm_ID     = data['aID']
                alarm_Status = data['aStatus']
                alarm = alarm_admin.get_alarm(alarm_ID)
                if alarm:
                    alarm.status = alarm_Status
                    alarm.save_to_db()
                    return {'message': 'Alarm status changed'}, 200
                else:
                    return {'message': 'Alarm not found'}, 403
            else:
                return {'message': 'User is orphan'}, 403
        else:
            return {'message': 'User not set properly'}, 403

# Get all alarm notify's connected to user or user's parent.
class GetAlarms(Resource):
    @jwt_required
    def post(self):
        alarmParser = reqparse.RequestParser()
        alarmParser.add_argument('aStatus', help = 'This field cannot be blank', required = True)
        data = alarmParser.parse_args()
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        if current_user:
            admin_u = current_user.find_prole("admin")
            if admin_u:
                status_list = json.loads(data['aStatus'])
                alarms = admin_u.get_alarms(status_list)
                if len(alarms) > 0:
                    alarm_List = [[d.alarm_name, d.description, d.alarm_type, d.alarm_level.name,
                                   d.raised_by.username, (d.toc).strftime("%d/%m/%Y, %H:%M:%S"), d.status,
                                   d.table.id, (d.data_ts).strftime("%Y-%m-%d"),
                                   d.id, d.data_serial, d.sensor.name, d.sensor_id, d.table.log_type] for d in alarms]
                    print(alarm_List)
                    return make_response(jsonify({'message': 'Alarms returned', 'alarms': alarm_List }), 200)
                else:
                    return {'message': 'No alarm are set'}, 204
            else:
               return {'message': 'User is orphan'}, 403
        else:
            return {'message': 'User not set properly'}, 403

class GetAlarmLevels(Resource):
    @role_required(["admin", "op_man", "it_man", "it_sec", "sys_admin"])
    def get(self):
        alarm_l = AlarmLevelModel.get_all()
        if len(alarm_l) > 0:
            alarm_List = [[d.name, d.description, d.id] for d in alarm_l]
            return {'message': 'Alarm Levels returned', 'alarms_levels': alarm_List }, 200
        else:
            return {'message': 'No alarm notifications are set'}, 204

# Create new registration key
class CreateRegiKey(Resource):
    @role_required(["sys_admin"])
    def post(self):
        regikeyParser = reqparse.RequestParser()
        regikeyParser.add_argument('keyName', help = 'This field cannot be blank', required = True)
        regikeyParser.add_argument('groupID', help = 'This field cannot be blank', required = True)

        data = regikeyParser.parse_args()
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)

        if current_user:
            keyName = data['keyName']
            group_id = data['groupID']
            group = GroupModel.find_by_id(group_id)
            if not group:
                return {'message': 'No group was found'}, 500

            check_k = True
            while check_k:
                api_K = secrets.token_hex(15)
                check_k = RegkeysModel.find_key(api_K)
            print("api key generated:", api_K)

            new_regkey = RegkeysModel(key = api_K, name = keyName)
            current_user.append_key(new_regkey)
            group.add_key(new_regkey)
            try:
                new_regkey.save_to_db()
                return {'message': 'Registration key generated'}, 200
            except:
                return {'message': 'Something went wrong'}, 500
        else:
            return {'message': 'User not set properly'}, 403

class GetGroups(Resource):
    @role_required(["sys_admin"])
    def get(self):
        group_l = GroupModel.get_all()
        if len(group_l) > 0:
            group_List = [[d.group_name, d.id] for d in group_l]
            return {'message': 'Groups returned', 'groups': group_List }, 200
        else:
            return {'message': 'No group are set'}, 204

class GetRegKeys(Resource):
    @role_required(["sys_admin"])
    def get(self):
        reg_l = RegkeysModel.get_all()
        if len(reg_l) > 0:
            reg_List = [[d.name, d.key, d.created_by.username ,
                         (d.toc).strftime("%d/%m/%Y, %H:%M:%S"),
                         d.active, d.group.group_name] for d in reg_l]
            return {'message': 'Groups returned', 'regkeys': reg_List }, 200
        else:
            return {'message': 'No group are set'}, 204

# Create alarm level
class CreateAlarmLevel(Resource):
    @role_required(["sys_admin"])
    def post(self):
        alarmParser = reqparse.RequestParser()
        alarmParser.add_argument('alName', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('alDesc')
        alarmParser.add_argument('alId')
        data = alarmParser.parse_args()
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)

        if current_user:
            al_name = data['alName']
            al_desc = data['alDesc']
            al_id = json.loads(data['alId'])
            print(al_id)
            #an_edit = data['anEdit']
            #print(an_edit)
            #if an_edit:
            if al_id:
                print("heeyoe")
                alarm_level = AlarmLevelModel.get_Level(al_id)
                if alarm_level:
                    alarm_level.name = al_name
                    alarm_level.description = al_desc
                    mm = 'Alarm Level modified'
                else:
                    return {'message': 'Alarm Level does not exists'}, 403
            else:
                alarm_level = AlarmLevelModel(name = al_name, description = al_desc)
                mm = 'Alarm Level created'
            try:
                alarm_level.save_to_db()
                return {'message': mm}, 200
            except:
                return {'message': 'Something went wrong'}, 500
        else:
            return {'message': 'User not set properly'}, 403


    # Create alarm notis
class CreateAlarmNoti(Resource):
    @role_required(["admin", "sys_admin"])
    def post(self):
        alarmParser = reqparse.RequestParser()
        alarmParser.add_argument('anName', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('anURL', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('userID')
        #alarmParser.add_argument('anEdit', help = 'This field cannot be blank', required = True)
        alarmParser.add_argument('anId')
        data = alarmParser.parse_args()
        #userID = get_jwt_identity()
        #current_user = UserModel.find_by_id(userID)

        for_uid = data['userID']
        userID = get_jwt_identity()
        initial_user = UserModel.find_by_id(userID)

        print(for_uid)

        if (initial_user.check_role("sys_admin")):
            if for_uid:
                current_user = UserModel.find_by_id(for_uid)
            else:
                return {'message': 'User not set'}, 403
        else:
            current_user = initial_user
        # Make check that url is valid!

        if current_user:
            an_name = data['anName']
            an_url = data['anURL']
            an_id = json.loads(data['anId'])
            print(an_id)
            #an_edit = data['anEdit']
            #print(an_edit)
            #if an_edit:
            if an_id:
                print("heeyoe")
                alarm_notice = current_user.get_notice(an_id)
                if alarm_notice:
                    alarm_notice.name = an_name
                    alarm_notice.url = an_url
                    mm = 'Alarm Notify Edited'
                else:
                    return {'message': 'Alarm Notice does not exits'}, 403
            else:
                alarm_notice = AlarmNotifyModel(name = an_name, url = an_url)
                current_user.add_an(alarm_notice)
                mm = 'Alarm Notify created'
            try:
                alarm_notice.save_to_db()
                return {'message': mm}, 200
            except:
                return {'message': 'Something went wrong'}, 500
        else:
            return {'message': 'User not set properly'}, 403

# Get all alarm notify's connected to user
class GetAlarmNoti(Resource):
    @role_required(["admin", "op_man", "it_man", "it_sec", "sys_admin"])
    def post(self):
        notiParser = reqparse.RequestParser()
        notiParser.add_argument('userID')
        data = notiParser.parse_args()
        for_uid = data['userID']
        userID = get_jwt_identity()
        initial_user = UserModel.find_by_id(userID)

        print(for_uid)

        if (initial_user.check_role("sys_admin")):
            if for_uid:
                current_user = UserModel.find_by_id(for_uid)
            else:
                return {'message': 'User not set'}, 403
        else:
            current_user = initial_user

        if current_user:
            admin_u = current_user.find_prole("admin")
            if admin_u:
                alarm_n = admin_u.alarm_notis.all()
                if len(alarm_n) > 0:
                    alarm_List = [[d.name, d.url, d.id] for d in alarm_n]
                    return {'message': 'Alarms returned', 'alarms_notify': alarm_List }, 200
                else:
                    return {'message': 'No alarm notifications are set'}, 204
            else:
                return {'message': 'User is orphan'}, 403
        else:
            return {'message': 'User not set properly'}, 403

class GetLogs(Resource):
    @role_required(["admin", "it_sec", "it_man", "op_man"])
    def post(self):
        probeParser = reqparse.RequestParser()
        probeParser.add_argument('probeid', help = 'This field cannot be blank', required = True)
        data = probeParser.parse_args()
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        if current_user:
            admin_u = current_user.find_prole("admin")
            if admin_u:
                probe_id = data['probeid']
                sensor_logs = admin_u.get_logtypes(probe_id)
                if sensor_logs:
                    print(sensor_logs)
                    # dt = sensor.tables.all()
                    # dt_list = [[table.log_type, table.id] for table in dt]
                    # dt_sorted = sorted(dt_list, key=lambda x: x[0])
                    dt = sensor_logs
                    dt_list = [[i, i] for i in dt]
                    dt_sorted = sorted(dt_list, key=lambda x: x[0])
                    return {'message': 'keys returned', 'dt_list': dt_sorted}, 200
                else:
                    return {'message': 'sensor is not found'}, 500
            else:
                return {'message': 'No admin user was found'}, 500
        else:
            return {'message': 'User not set properly'}, 403
    
class getPossibleDates(Resource):
    @role_required(["admin", "it_sec", "it_man", "op_man"])
    def post(self):
        dateParser = reqparse.RequestParser()
        dateParser.add_argument('probeid', help = 'This field cannot be blank', required = True)
        dateParser.add_argument('logid', help = 'This field cannot be blank', required = True)
        data = dateParser.parse_args()

        probeid = data['probeid']
        logid = data['logid']

        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        
        if current_user:
            if logid == "com_logs":
                tables = current_user.get_logs(probeid)
            elif logid:
                tables = current_user.get_log_by_types(probeid, logid)
                
            if tables:
                logs_all = {}

                for i in tables:
                    fields = (i.column_order).split(',')
                    nn = [i.table_name]
                    print(nn)
                    if i.log_type in logs_all:
                        logs_all[i.log_type]['logs'].append(nn)
                    else:
                        logs_all[i.log_type] = {'logs': []}
                        logs_all[i.log_type]['logs'].append(nn)

                com_call = []
                params = []
                for j in logs_all.keys():
                    logs = logs_all[j]['logs']
                    for d in logs:
                        tab_name = d[0]
                        c_sql = "SELECT DISTINCT to_char(ts, 'YYYY-MM-DD') as dates FROM " + tab_name + " WHERE user_id=%s AND sensor_id=%s"
                        com_call.append(c_sql)
                        params.extend([current_user.id, probeid])

                t = time.perf_counter()
                sql_query = ' UNION '.join(com_call)
                result = db.engine.execute(sql_query, tuple(params))
                query_data = result.fetchall()
                print(time.perf_counter() - t)

                if query_data:
                    listStringsDates = []
                    for i in query_data:
                        listStringsDates.append(i[0])
                    return {'message': 'dates returned', 'dates': listStringsDates}, 200

class GetSensors(Resource):
    @role_required(["admin", "it_sec", "it_man", "op_man"])
    def get(self):
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        if current_user:
            admin_u = current_user.find_prole("admin")
            if admin_u:
                sensors = admin_u.sensors.all()
                print(len(sensors))
                if len(sensors) > 0:
                    sensor_List = [["Sensor Name", "Api Key", "Sensor Description"]] + [[d.name, d.api_key, d.description, d.sensor_id] for d in sensors]

                    return {'message': 'keys returned', 'api_keys': sensor_List}, 200
                else:
                    return {'message': 'No api key is set '}, 204
            else:
                return {'message': 'No admin user was found'}, 204
        else:
            return {'message': 'User not set properly'}, 403

class CheckApiKey(Resource):
    def post(self):
        data = keyParser.parse_args()
        #current_user = UserModel.find_by_username(username)
        if UserModel.check_apikey(data['username'], data['apikey']): #checkapikey(data['username'], data['apikey']):
            return {'message': 'api key works'}, 200
        else:
            return {'message': 'apikey not set or wrong api login credentials'}, 403

class GetRoles(Resource):
    @role_required(['admin', 'sys_admin'])
    def get(self):
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        role_list = current_user.roles
        t_list = current_user.get_createable_roles()
        createable_roles = [[d.name, d.id, d.description] for d in t_list]
        return {'roles': createable_roles}, 200


class UserSettings(Resource):
    @jwt_required
    def post(self):
        parser = reqparse.RequestParser()
        parser.add_argument('password')

        parser.add_argument('zipcode')
        parser.add_argument('address')
        parser.add_argument('mobile')
        parser.add_argument('name')
        data = parser.parse_args()

        new_pass = data['password']
        new_zip = data['zipcode']
        new_address = data['address']
        new_mobile = data['mobile']
        new_name = data['name']

        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)

        if new_pass:
            pass_hash = UserModel.generate_hash(data['password'])
            current_user.password = pass_hash
        else:
            current_user.mobile = new_mobile
            current_user.zipcode = new_zip
            current_user.address = new_address
            current_user.name = new_name
        try:
            current_user.save_to_db()
            return {'message': 'User has changed information'}, 200
        except:
            return {'message': 'Something went wrong internally'}, 500
    @jwt_required
    def get(self):
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        if current_user:
            return {'zipcode': current_user.zipcode,
                    'address': current_user.address,
                    'mobile': current_user.mobile,
                    'name': current_user.name}, 200
        else:
            return {'message': 'User could not be found'}, 403

class UserRegistration(Resource):
    @role_required(["admin"])
    def post(self):
        parser = reqparse.RequestParser()
        parser.add_argument('username', help = 'This field cannot be blank', required = True)
        parser.add_argument('password', help = 'This field cannot be blank', required = True)
        parser.add_argument('roles', help = 'This field cannot be blank', required = True)
        parser.add_argument('mobile', help = 'This field cannot be blank', required = True)
        data = parser.parse_args()

        if UserModel.find_by_username(data['username']):
            return {'userN': 'User {} already exists'.format(data['username'])}, 500
        elif not check_email(data['username']):
            return {'userN': 'User name have to be an email'.format(data['username'])}, 500

        roles = json.loads(data["roles"])
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        t_list = [d.id for d in current_user.get_createable_roles()]
        for i in roles:
            if i not in t_list:
                return {'role': 'You do not have permission to grant this role'}, 500

        new_user = UserModel(
            username = data['username'],
            password = UserModel.generate_hash(data['password']),
            mobile = data['mobile']
        )

        new_user.append_roles(roles)
        current_user.append_child(new_user)
        group = current_user.group
        group.add_user(new_user)

        try:
            new_user.save_to_db()
            return {'message': 'User {} was created'.format(data['username'])}, 200
        except:
            return {'message': 'Something went wrong internally'}, 500

# Get all users
class SysGetUserList(Resource):
    @role_required(["sys_admin"])
    def get(self):
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        if current_user:
            users = current_user.get_all()
            if len(users) > 0:
                user_list = [[d.username, d.name, d.mobile, d.zipcode, d.address,
                              (d.toc).strftime("%d/%m/%Y - %H:%M:%S"), d.get_roles_names(), d.active, d.id] for d in users]
                print(user_list)
                return make_response(jsonify({'message': 'User list returned', 'users': user_list }), 200)
            else:
                return {'message': 'No users have been created'}, 204
        else:
            return {'message': 'User not set properly'}, 403

    @role_required(["sys_admin"])
    def post(self):
        parserK = reqparse.RequestParser()
        parserK.add_argument('userid', help = 'This field cannot be blank', required = True)
        parserK.add_argument('active', help = 'This field cannot be blank', required = True)
        data = parserK.parse_args()

        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        edit_user = UserModel.find_by_id(data['userid'])
        if current_user and edit_user:
            edit_user.active = json.loads(data['active'])
            t_list = [d.id for d in current_user.get_createable_roles()]
            try:
                edit_user.save_to_db()
                return {'message': 'User was edited'}, 200
            except:
                return {'message': 'Something went wrong internally'}, 500
        else:
            return {'message': 'User not set properly'}, 403


# Get all users created by the current user
class GetUserList(Resource):
    @role_required(["admin"])
    def get(self):
        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        if current_user:
            users = current_user.children
            if len(users) > 0:
                user_list = [[d.username, d.name, d.mobile, d.zipcode, d.address, (d.toc).strftime("%d/%m/%Y - %H:%M:%S"), d.active, d.get_roles_id(), d.id, ",".join(d.get_roles_names())] for d in users]
                print(user_list)
                return make_response(jsonify({'message': 'User list returned', 'users': user_list }), 200)
            else:
                return {'message': 'No users have been created'}, 204
        else:
            return {'message': 'User not set properly'}, 403

    @role_required(["admin"])
    def post(self):
        parserK = reqparse.RequestParser()
        parserK.add_argument('userid', help = 'This field cannot be blank', required = True)
        parserK.add_argument('roles', help = 'This field cannot be blank', required = True)
        parserK.add_argument('active', help = 'This field cannot be blank', required = True)
        data = parserK.parse_args()

        userID = get_jwt_identity()
        current_user = UserModel.find_by_id(userID)
        roles = json.loads(data["roles"])
        edit_user = UserModel.find_by_id(data['userid'])
        if current_user and edit_user:
            if edit_user.parent_id == current_user.id:
                edit_user.active = json.loads(data['active'])
                t_list = [d.id for d in current_user.get_createable_roles()]
                for i in roles:
                    if i not in t_list:
                        return {'role': 'You do not have permission to grant this role'}, 500
                edit_user.append_roles_reset(roles)
                try:
                    edit_user.save_to_db()
                    return {'message': 'User was edited'}, 200
                except:
                    return {'message': 'Something went wrong internally'}, 500
            else:
                return {'message': 'User is not the right child'}, 403

        else:
            return {'message': 'User not set properly'}, 403

class KeyUserRegistration(Resource):

    def post(self):
        parserK = reqparse.RequestParser()
        parserK.add_argument('username', help = 'This field cannot be blank', required = True)
        parserK.add_argument('password', help = 'This field cannot be blank', required = True)
        parserK.add_argument('key', help = 'This field cannot be blank', required = True)
        parserK.add_argument('zipcode', help = 'This field cannot be blank', required = True)
        parserK.add_argument('address', help = 'This field cannot be blank', required = True)
        parserK.add_argument('mobile', help = 'This field cannot be blank', required = True)
        parserK.add_argument('name', help = 'This field cannot be blank', required = True)
        data = parserK.parse_args()

        reg_key = RegkeysModel.check_key(data['key'])
        if not reg_key:
            return {'key': 'Registration key is not valid'}, 500
        elif UserModel.find_by_username(data['username']):
            return {'userN': 'User {} already exists'.format(data['username'])}, 500
        elif not check_email(data['username']):
            return {'userN': 'User name have to be an email'.format(data['username'])}, 500

        new_user = UserModel(
            username = data['username'],
            password = UserModel.generate_hash(data['password']),
            mobile = data['mobile'],
            zipcode = data['zipcode'],
            address = data['address'],
            name = data['name']
        )

        adminR = RoleModel.find_by_rolename("admin")
        new_user.roles.append(adminR)
        reg_key.active = False
        group = reg_key.group
        group.add_user(new_user)

        try:
            new_user.save_to_db()
            current_user = UserModel.find_by_username(data['username'])
            access_token = create_access_token(identity = current_user.get_ID())
            refresh_token = create_refresh_token(identity = current_user.get_ID())
            return {
                'message': 'User {} was created'.format(data['username']),
                'access_token': access_token,
                'refresh_token': refresh_token
            }
        except:
            return {'message': 'Something went wrong'}, 500


class UserLogin(Resource):
    def post(self):
        data = parser.parse_args()

        if not check_email(data['username']):
            return {'message': 'User name have to be an email'.format(data['username'])}, 500

        current_user = UserModel.find_by_username(data['username'])

        # TODO: Check for XSS
        if not current_user:
            return {'message': 'User {} doesn\'t exist'.format(data['username'])}, 500


        if current_user and UserModel.verify_hash(data['password'], current_user.password) and current_user.active:
            access_token = create_access_token(identity = current_user.get_ID())
            refresh_token = create_refresh_token(identity = current_user.get_ID())
            roles = current_user.get_roles()
            return {
                'message': 'Logged in as {}'.format(current_user.username),
                'user_name': format(current_user.username),
                'access_token': access_token,
                'refresh_token': refresh_token,
                'roles': roles
            }
        else:
            return {'message': 'Wrong credentials'}, 500


class UserLogoutAccess(Resource):
    @jwt_required
    def post(self):
        jti = get_raw_jwt()['jti']
        try:
            revoked_token = RevokedTokenModel(jti = jti)
            revoked_token.add()
            return {'message': 'Access token has been revoked'}
        except:
            return {'message': 'Something went wrong'}, 500


class UserLogoutRefresh(Resource):
    @jwt_refresh_token_required
    def post(self):
        jti = get_raw_jwt()['jti']
        try:
            revoked_token = RevokedTokenModel(jti = jti)
            revoked_token.add()
            return {'message': 'Refresh token has been revoked'}
        except:
            return {'message': 'Something went wrong'}, 500


class TokenRefresh(Resource):
    @jwt_refresh_token_required
    def post(self):
        current_userID = get_jwt_identity()
        access_token = create_access_token(identity = current_userID)
        return {'access_token': access_token}

class ConnLog(Resource):
    def __init__(self):
        print("initializing connlog")
        with open("sample_data.json", "r") as f:
            self.data=json.loads(f.read())['files']['conn.log']

    def applyfilter(self, filter, data):
        # The filter is a composite filter
        if 'condition' in filter:
            cond = filter['condition']
            if cond == 'and':
                result = True
                for subfilt in filter['rules']:
                    result = result and self.applyfilter(subfilt, data)
                return result
            elif cond == 'or':
                result = False
                for subfilt in filter['rules']:
                    result = result or self.applyfilter(subfilt, data)
                return result
            else:
                print("Warning: unimplemented condition.")
                return False
        # The filter is a simple filter
        elif 'field' in filter:
            if filter['operator'] == '=':
                return (data[filter['field']] == filter['value'])
            elif filter['operator'] == '!=':
                return (data[filter['field']] != filter['value'])
            else:
                print("Warning: unimplemented operator.")
                return False
        # Unknown filter
        else:
            print("Warning: unknown filter type.")
            return False

    @jwt_required
    def post(self):
        fp = filterparser.parse_args()
        filter = json.loads(fp['filter'])

        # Debug
        print(filter)

        d = dict(self.data)

        res = []
        for r in d['rows']:
            z = dict(zip(d['header'],r))
            if self.applyfilter(filter, z):
                res.append(r)
        d['rows'] = res

        return d

    @jwt_required
    def get(self):
        return self.data


class UploadPcap(Resource):
    @jwt_required
    def post(self):
        parse = reqparse.RequestParser()
        parse.add_argument('file', type=werkzeug.datastructures.FileStorage, location='files')
        args = parse.parse_args()
        pcapFile = args['file']
        if pcapFile:
            current_ID = get_jwt_identity()
            fileuuid = uuid.uuid4()

            current_user = UserModel.find_by_id(current_ID)
            # TODO: Check current_user var for bad chars. Perhaps have a uuid per user instead.
            if not os.path.isdir(storage+"pcaps/" + current_user.get_ID()):
                os.makedirs(storage+"pcaps/" + current_user.get_ID())
            pcapFile.save(storage+"pcaps/" + current_user.get_ID() + "/" + str(fileuuid) + ".pcap")
            return {'message': 'File Uploaded'}, 200
        else:
            return {'message': 'No file was given'}, 500

class Pcap_unpro(Resource):
    @jwt_required
    def get(self):
        current_ID = get_jwt_identity()
        current_user = UserModel.find_by_id(current_ID)
        pcap_path = storage+"pcaps/"+current_user.get_ID()
        logs = []
        if (os.path.exists(pcap_path)):
            logs = os.listdir(pcap_path)
        return { "pcap_wait": logs }

# class BroLogs(Resource):
#     @jwt_required
#     def get(self):
#         current_ID = get_jwt_identity()
#         current_user = UserModel.find_by_id(current_ID)
#         brolog_path = storage+"brologs/"+current_user.get_ID()
#         logs = []
#         if (os.path.exists(brolog_path)):
#             logs = os.listdir(brolog_path)
#         # Check for only pcaps
#         return { "brologs": logs }


# class BroLog(Resource):
#     @jwt_required
#     def get(self, brologuuid):
#         current_ID = get_jwt_identity()
#         current_user = UserModel.find_by_id(current_ID)
#         if brologuuid.endswith(".json") and brologuuid!=".json":
#             brologuuid = brologuuid[:-5]
#         if not bool(re.fullmatch(r'[a-zA-Z0-9-]+', brologuuid)):
#             return {"Error":"Bad brologuuid"}
#         with open(storage+"brologs/" + current_user.get_ID() + "/" + brologuuid + ".json", "r") as f:
#             j = json.loads(f.read())
#         #return j
#         maxHL = getMaxL(j["files"])
#         #hideCol(j["files"])
#         all_args = request.args.get("hideC")
#         print("this is the aargs:",all_args)
#         #print("this is maxL:", maxHL)
#         #print("this is the files:", j["files"])
#         return {"bdata":j, "maxHL": maxHL}

#     @jwt_required
#     def post(self, brologuuid):
#         current_ID = get_jwt_identity()
#         current_user = UserModel.find_by_id(current_ID)

#         getPars = request.get_json()
#         fp    = json.loads(getPars["filter"])
#         hideC = json.loads(getPars["hideC"])
#         startP = json.loads(getPars["startP"])
#         data_served = json.loads(getPars['dataSer'])
#         search_F = json.loads(getPars['searchF'])
#         print("this is the search field:", search_F)
#         print("this si the fp:", fp)

#         # Read data
#         if brologuuid.endswith(".json") and brologuuid!=".json":
#             brologuuid = brologuuid[:-5]
#         if not bool(re.fullmatch(r'[a-zA-Z0-9-]+', brologuuid)):
#             return {"Error":"Bad brologuuid"}
#         j=''
#         with open(storage+"brologs/" + current_user.get_ID() + "/" + brologuuid + ".json", "r") as f:
#             j = json.loads(f.read())

#         resdata = j
#         # Apply filter to data

#         print("res data before fp", sum(map(lambda x: len(x['rows']), resdata['files'].values())))
#         if(fp is not None ):
#             if brologuuid.endswith(".json") and brologuuid!=".json":
#                 brologuuid = brologuuid[:-5]
#             if not bool(re.fullmatch(r'[a-zA-Z0-9-]+', brologuuid)):
#                 return {"Error":"Bad brologuuid"}

#             pnffilter = Pnffilter()
#             beforefiltering = time.time()
#             resdata = pnffilter.filterlistdata(fp, j)
#             print("res data mid fp", sum(map(lambda x: len(x['rows']), resdata['files'].values())))
#             afterfiltering = time.time()
#             print("Filter time: ", str(afterfiltering - beforefiltering))
#         print("res data after fp", sum(map(lambda x: len(x['rows']), resdata['files'].values())))

#         totalsize = sum(map(lambda x: len(x['rows']), resdata['files'].values()))
#         altData, heads = hideCol(resdata, hideC)
#         maxHL = getMaxL(resdata["files"])
#         logList, logHeader, filesID = formatdata(altData, maxHL)
#         searchR = None

#         if (search_F):
#             x, y = search(logList, startP+1, search_F)
#             if x and y:
#                 if x > (data_served // 2):
#                     startP = x - (data_served // 2)
#                     x = x - startP
#                 else:
#                     startP = 0
#                 cut_logList = cut(logList, startP, data_served)
#                 searchR = [x,y]
#             else:
#                 cut_logList = None
#                 searchR = None
#         else:
#             print("search not touched")
#             cut_logList = cut(logList, startP, data_served)
#             searchR = None

#         return {'bdata': altData, 'maxHL': maxHL, 'headers': heads,
#                 'totalSize': totalsize, 'logList': cut_logList, 'logHead': logHeader,
#                 'filesID': filesID, 'searchRes': searchR, 'newStartP': startP}


class EditDataTable(Resource):
    @role_required(["admin", "it_sec",  "it_man", "op_man"])
    def get(self):
        current_ID = get_jwt_identity()
        current_user = UserModel.find_by_id(current_ID)

        if current_user:
            admin_u = current_user.find_prole("admin")
            if admin_u:
                log_tables = current_user.get_all_logs()
                resdata = []
                logs_all = {}
                for i in log_tables:
                    fields = (i.column_order).split(',')
                    fields.remove('ts')
                    if i.log_type in logs_all:
                        logs_all[i.log_type]= list(set(logs_all[i.log_type] + fields))
                    else:
                        logs_all[i.log_type] = fields
                dd = 0
                for v in logs_all:
                    log_f = list(map(lambda x: [v, x, v+"-"+x], logs_all[v]))
                    resdata.extend(log_f)
                return {'edit_headers': resdata}, 200
            else:
                return {'message': 'No admin user was found'}, 204
        else:
            return {'message': 'User was not set'}, 204

class GetLogData(Resource):
    @role_required(["admin", "it_sec",  "it_man", "op_man"])
    def post(self):
        parse = reqparse.RequestParser()
        parse.add_argument('filter', help = 'This field cannot be blank', required = True)
        parse.add_argument('hideC', help = 'This field cannot be blank', required = True)
        parse.add_argument('startP', help = 'This field cannot be blank', required = True)
        parse.add_argument('dataSer', help = 'This field cannot be blank', required = True)
        parse.add_argument('searchF', help = 'This field cannot be blank', required = True)
        parse.add_argument('dates', help = 'This field cannot be blank', required = True)
        parse.add_argument('probeid', help = 'This field cannot be blank', required = True)
        parse.add_argument('logid', help = 'This field cannot be blank', required = True)
        args = parse.parse_args()

        fp          = json.loads(args["filter"])
        hideC_raw   = json.loads(args["hideC"])
        startP      = json.loads(args["startP"])
        data_served = json.loads(args['dataSer'])
        search_F    = json.loads(args['searchF'])
        probeid     = args['probeid']
        logid       = args['logid']
        dates       = json.loads(args['dates'])

        hideC = {}
        for i in hideC_raw:
            logT = i['row_type']
            logF = i['h_title']
            if logF == 'ts':
                continue
            if logT in hideC:
                hideC[logT][logF] = 1
            else:
                hideC[logT] = {}
                hideC[logT][logF] = 1

        if not dates:
            return {'message': 'Dates have to be selected'}, 400
        if (not probeid.isdigit()) and (logid != "com_logs") and (not logid.isidigt()):
            return {'message': 'ProbeID not acceptable'}, 400

        current_ID = get_jwt_identity()
        current_user = UserModel.find_by_id(current_ID)
        if current_user:
            admin_u = current_user.find_prole("admin")
            if not admin_u:
                return {'message': 'No admin user was found'}, 204
        else:
            return {'message': 'User was not set'}, 204


        resdata = {'files': {}}
        single = True
        totalsize = 0
        log_tables = []

        if len(dates) == 2:
            try:
                dateT1 = dt.strptime(dates[0], "%Y-%m-%d")
                dateT2 = dt.strptime(dates[1], "%Y-%m-%d")
            except ValueError:
                return {'message': 'Dates given are not of the format y-m-d'}, 400

            if dateT1 > dateT2:
                startdate = dateT2.strftime("%Y-%m-%d")
                enddate   = (dateT1 + timedelta(days=1)).strftime("%Y-%m-%d")
            else:
                startdate = dateT1.strftime("%Y-%m-%d")
                enddate   = (dateT2 + timedelta(days=1)).strftime("%Y-%m-%d")
        else:
            try:
                dateT1 = dt.strptime(dates[0], "%Y-%m-%d")
            except ValueError:
                return {'message': 'Dates given are not of the format y-m-d'}, 400
            startdate = dateT1.strftime("%Y-%m-%d")
            enddate   = (dateT1 + timedelta(days=1)).strftime("%Y-%m-%d")

        # Check whether it's a single log type or combined
        if logid == "com_logs":
            log_tables = admin_u.get_logs(probeid)
            single = False
        elif logid:
            log_tables = admin_u.get_log_by_types(probeid, logid)

        # prepare sql statement and insert difference columns between same logs, UNION ALL requires this
        if log_tables:
            logs_all = {}
            for i in log_tables:
                fields = (i.column_order).split(',')
                print(fields)
                nn = [i.table_name, fields, i.log_type, i.id]
                if i.log_type in logs_all:
                    logs_all[i.log_type]['logs'].append(nn)
                    current_un = logs_all[i.log_type]['unqFields']
                    logs_all[i.log_type]['unqFields'].extend(x for x in fields if x not in current_un)
                else:
                    logs_all[i.log_type] = {'logs': [], 'unqFields': []}
                    logs_all[i.log_type]['logs'].append(nn)
                    logs_all[i.log_type]['unqFields'] = fields
            
            for j in logs_all.keys():
                logs = logs_all[j]['logs']
                unique_f = logs_all[j]['unqFields']
                com_call = []
                params = []
                log_type = j
                for d in logs:
                    tab_name = d[0]
                    fields = d[1]
                    columns = [i if i in fields else "NULL as "+i for i in unique_f]
                    c_sql = "SELECT '"+str(d[2])+"' AS Log_Type, id AS dto_serial, '"+str(d[3])+"' AS dto_id, "+(','.join(columns))+" FROM "+tab_name+" WHERE user_id=%s AND sensor_id=%s and (ts >= %s AND ts < %s)"
                    com_call.append(c_sql)
                    params.extend([admin_u.id, probeid, startdate, enddate])

                sql_query = ' UNION ALL '.join(com_call) + " ORDER BY ts"
                result = db.engine.execute(sql_query, tuple(params))
                query_data = result.fetchall()
                #totalsize += len(query_data)
                if query_data:
                    rows_data = [['-' if v is None else v for v in list(row)] for row in query_data]
                    rows_header = list(query_data[0].keys())
                    print(log_type)
                    resdata['files'][log_type] = {'header': rows_header, 'rows': rows_data}
        else:
            return {'message': 'No log found'}, 400

        # checks making sure functino runs flawless
        if not single and not 'conn' in resdata['files']:
            return {'message': 'No conn logs for that date period'}, 400
        elif not resdata['files']:
            return {'message': 'No data for that period'}, 400

        # Apply filter to data

        print("res data before fp", sum(map(lambda x: len(x['rows']), resdata['files'].values())))
        if(fp is not None ):

            pnffilter = Pnffilter()
            beforefiltering = time.time()
            resdata = pnffilter.filterlistdata(fp, resdata)
            print("res data mid fp", sum(map(lambda x: len(x['rows']), resdata['files'].values())))
            afterfiltering = time.time()
            print("Filter time: ", str(afterfiltering - beforefiltering))
        fpCount = sum(map(lambda x: len(x['rows']), resdata['files'].values()))
        print("res data after fp", fpCount)

        if fpCount < 1:
            return {'message': 'No data left when filter was applied'}, 400

        totalsize = sum(map(lambda x: len(x['rows']), resdata['files'].values()))
        altData = hideCol(resdata, hideC)
        maxHL = getMaxL(resdata["files"])
        print(altData["files"].keys())
        logList, logHeader, filesID = formatLogData(altData, maxHL, single)
        searchR = None
        print("heyo!")
        print(logHeader)
        if (search_F):
            x, y = search(logList, startP+1, search_F)
            if x and y:
                if x > (data_served // 2):
                    startP = x - (data_served // 2)
                    x = x - startP
                else:
                    startP = 0
                cut_logList = cut(logList, startP, data_served)
                searchR = [x,y]
            else:
                cut_logList = None
                searchR = None
        else:
            cut_logList = cut(logList, startP, data_served)
            searchR = None
        print("this is cut sized length", len(cut_logList))

        return jsonify({'maxHL': maxHL,
                        'totalSize': totalsize, 'logList': cut_logList, 'logHead': logHeader,
                        'filesID': filesID, 'searchRes': searchR, 'newStartP': startP})

class GetHelp(Resource):
    @jwt_required
    def get(self):
        tips = get_tips("csv/helpPage.csv")
        return { "tips": tips }

def append_dict(init_dict, add_dict):
    for i in add_dict:
        if i in init_dict:
            init_dict[i] = init_dict[i] + add_dict[i]
        else:
            init_dict[i] = add_dict[i]
    return init_dict

## FIX! should fill in missing months, does not do it proper.
def check_dict(data):
    k_list = list(data.keys())
    v_list = [item for sublist in list(map(lambda x: list(x.keys()),list(data.values()))) for item in sublist]

    for j in k_list:
        for i in v_list:
            if not (i in data[j]):
                data[j][i] = 0

    # for i in range(0, len(k_list)-1):
    #     print("heyo sdf s- "+str(i))
    #     if set(data[k_list[i]]) != set(data[k_list[i+1]]):
    #         diff_s = set(data[k_list[i]]) - set(data[k_list[i+1]])
    #         print(diff_s)
    #         for j in diff_s:
    #             if j in data[k_list[i]]:
    #                 data[k_list[i+1]][j] = 0
    #             else:
    #                 for v in range(0, i):
    #                     data[k_list[i]][j] = 0
    return data

def prepare_forjs(data_dict, sort=True):
    bb = []
    sort_head = list(data_dict.keys())
    if sort:
        sort_head.sort()
    sort_keys = list(list(data_dict.values())[0].keys())
    sort_keys.sort(key=lambda date: dt.strptime(date, "%Y-%b"))
    #print(sort_keys)

    for i in sort_head:
        mainD = data_dict[i]
        data_s = [mainD[d] for d in sort_keys]
        bb.append({"name": i, "data": data_s})

    return bb, sort_keys, sort_head

class GetDashData(Resource):
    @role_required(["admin", "it_sec",  "it_man", "op_man", "management"])
    def get(self):
        current_ID = get_jwt_identity()
        current_user = UserModel.find_by_id(current_ID)
        if not current_user:
            return {'message': "User not logged in"}, 403
        alarm_admin = current_user.find_prole("admin")
        if alarm_admin:
            cdata = None
            chead = None
            clog = None
            aldata = None
            alhead = None
            allog = None
            agdata = None
            aghead = None
            aglog = None

            # get alarm stats
            alarm_l = {'0_Risk': 0, '0_High Risk': 0, '0_Very High Risk': 0,
                       '1_Risk': 0, '1_High Risk': 0, '1_Very High Risk': 0,
                       '2_Risk': 0, '2_High Risk': 0, '2_Very High Risk': 0}
            sensor_list = alarm_admin.get_sensor_id()
            if sensor_list:
                a_sql = "SELECT count(*) as a_count, alarm_level.name as al_name, alarm.status as status FROM alarm LEFT JOIN alarm_level ON alarm.al_id=alarm_level.id WHERE sensor_id = ANY(:ids) GROUP by al_name, status;"
                result = db.engine.execute(sqlalchemy.text(a_sql), ids=sensor_list)
                query_data = result.fetchall()
                if query_data:
                    for i in query_data:
                        level = i.al_name
                        alarm_l[str(i.status)+"_"+level] = i.a_count


                # get local alarm trends
                local_sql = "SELECT concat(extract(year from toc), '-', TO_CHAR(alarm.toc, 'Mon')) "\
                    +"as d_period, count(*) as a_count, alarm_level.name as al_name FROM alarm LEFT "\
                    +"JOIN alarm_level ON alarm.al_id=alarm_level.id WHERE sensor_id = ANY(:ids) GROUP BY d_period, status, al_name;"
                result = db.engine.execute(sqlalchemy.text(local_sql), ids=sensor_list)
                query_data = result.fetchall()
                aldata, alhead, allog = None, None, None
                if query_data:
                    al_data = OrderedDict({'Risk' : {}, 'High Risk': {}, 'Very High Risk' : {}})
                    for i in query_data:
                        new_entry = {i.d_period : i.a_count}
                        if i.al_name in al_data:
                            al_data[i.al_name] = append_dict(al_data[i.al_name], new_entry)
                        else:
                            al_data[i.al_name] = new_entry

                    if len(al_data) > 1:
                        al_data = check_dict(al_data)
                    aldata, alhead, allog = prepare_forjs(al_data, False)
            # get global alarm trends
            global_sql = "SELECT concat(extract(year from toc), '-', TO_CHAR(alarm.toc, 'Mon')) "\
                +"as d_period, count(*) as a_count, alarm_level.name as al_name FROM alarm LEFT "\
                +"JOIN alarm_level ON alarm.al_id=alarm_level.id GROUP BY d_period, status, al_name;"
            result = db.engine.execute(global_sql)
            query_data = result.fetchall()
            print(query_data)
            agdata, aghead, aglog = None, None, None
            if query_data:
                ag_data = OrderedDict({'Risk' : {}, 'High Risk': {}, 'Very High Risk' : {}})
                for i in query_data:
                    new_entry = {i.d_period : i.a_count}
                    if i.al_name in ag_data:
                        ag_data[i.al_name] = append_dict(ag_data[i.al_name], new_entry)
                    else:
                        ag_data[i.al_name] = new_entry

                if len(ag_data) > 1:
                    ag_data = check_dict(ag_data)
                agdata, aghead, aglog = prepare_forjs(ag_data, False)

            accept_tabs = ['conn', 'dns', 'ssl', 'http']
            tabs = alarm_admin.get_all_tables(accept_tabs)
            res_list = OrderedDict()

            for v in tabs:
                c_sql = "SELECT concat(extract(year from ts), '-', TO_CHAR(ts, 'Mon'))"\
                    +" as d_period, count(*) as c_conn FROM "\
                    +v.table_name+" WHERE user_id=%s GROUP BY d_period;"
                result = db.engine.execute(c_sql, (alarm_admin.id,))
                query_data = result.fetchall()
                if query_data:
                    if v.log_type in res_list:
                        res_list[v.log_type] = append_dict(res_list[v.log_type], dict(query_data))
                    else:
                        res_list[v.log_type] = dict(query_data)

            if res_list:
                if len(res_list) > 1:
                    res_list = check_dict(res_list)
                cdata, chead, clog = prepare_forjs(res_list)

            print(cdata)
            print(chead)
            return {'cdata': cdata, 'chead': chead, 'logTypes': clog,
                    'alarmStats': alarm_l, 'agData': agdata,
                    'agHead': aghead, 'agLog' : aglog, 'alData' : aldata,
                    'alHead' : alhead, 'alLog' : allog}
        else:
            return {'message': 'User is orphan'}, 403

from flask_jwt_extended import get_jwt_identity
from angle.models import db, UserModel, RoleModel, MessageModel, GroupModel
from flask_restful import Resource, reqparse
from angle import role_required
from flask_mail import Message, Mail
import json
from flask import current_app as app
from flask import render_template
import os
import pandas as pd

image_url = os.path.join(app.config['CURRENT_IMAGE_SITE'], app.config['IMAGE_FOLDER'])

def sendMail(subject, recipients, body, alarmType, mail):
    msg = Message(subject, recipients = recipients)
    msg.html = render_template('email_template.html', icon=os.path.join(image_url, "new-user.png"), head="Trend Notification", gmodText=body, alarmType=alarmType, color="orange")
    mail.send(msg)
    return True

class SendAlarmMail(Resource):
    @role_required(["group_moderator"])
    def post(self):
        parser = reqparse.RequestParser()
        parser.add_argument('subject', help = 'This field cannot be blank', required = True)
        parser.add_argument('text', help = 'This field cannot be blank', required = True)
        parser.add_argument('recipients', help = 'This field cannot be blank', required = True)
        parser.add_argument('alarmType', help = 'This field cannot be blank', required = True)

        data = parser.parse_args()

        current_ID = get_jwt_identity()
        current_user = UserModel.find_by_id(current_ID)

        if not current_user:
            app.logger.error('user with ID: {0} tried sending alarm emails'.format(current_ID))
            return {'message': "User not logged in"}, 403
        emailText = data['text']

        emailSubject = data['subject']
        emailAlarmType = data['alarmType']
        emailRecipients = json.loads(data['recipients'])

        roles = []

        group = current_user.get_group()

        # get pandas dataframe containing userdata
        admin_list = group.get_msg_rec(['admin'])
        user_list = group.get_msg_rec(emailRecipients)

        # get list of firm_id
        firm_list = user_list.firm_id.unique()

        # match against
        missing_users = admin_list[~admin_list["firm_id"].isin(firm_list)]

        print('firm_list:', firm_list)
        print('user_list:', user_list)
        print('admin_list', admin_list)
        print('missing users:', missing_users)

        if not missing_users.empty:
            recipients = (user_list.append(missing_users)

        print(user_list)

        recipients = list(user_list.username.unique())

        print(recipients)

        #user_list = pd.read_sql_query(query.statement, engine)

        # print(user_list)
        # print('missing_users:', missing_users)

        # return {'message': 'succes'}, 200

        # for i in emailRecipients:
        #     if i not in [i.un for i in RoleModel.get_all_roles([])]:
        #         app.logger.error('{0} - {1} tried sending alarm emails to recipients/roles that does not exists'.format(current_user.name, current_user.id))
        #         return {'message': 'Nonexisting Recipients/Roles Given'}, 500
        #     roles.append([i for i in (RoleModel.find_by_rolename(i)).users])

        # recipients = list(dict.fromkeys([recipient.username for recipients in roles for recipient in recipients]))

        if app.config['MAIL_ACTIVE']:
            mail = Mail(app)
            try:
                sendMail(emailSubject, recipients, emailText, emailAlarmType, mail)
            except:
                return {'message': 'mailFail'}, 500

        MessageModel.create_message(current_ID, emailSubject, emailText, emailRecipients)

        app.logger.info('{0} - {1} sent alarm mails'.format(current_user.name, current_user.id))
        return {'message': 'succes'}, 200
